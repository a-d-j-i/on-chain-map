{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-f3d49bc09f2abc602e857baa3a665874a86c0617",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SparseMap.sol": "project/contracts/SparseMap.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SparseMap.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {TileWithCoordLib} from \"./TileWithCoordLib.sol\";\nimport {TileLib} from \"./TileLib.sol\";\n\n/// @title SparseMap Library\n/// @author aadjiman@gmail.com\n/// @notice Library for managing a sparse map of tiles with coordinates\n/// @dev Implements functionality for adding, removing, checking, and manipulating tiles in a sparse map\nlibrary SparseMap {\n    using TileWithCoordLib for TileWithCoordLib.TileWithCoord;\n\n    using TileLib for TileLib.Tile;\n\n    /// @notice Map structure to store tiles with coordinates\n    /// @dev To remove empty tiles we need to store the key (aka coords) inside the value\n    struct Map {\n        TileWithCoordLib.TileWithCoord[] values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(uint256 => uint256) indexes;\n    }\n\n    struct TileWithCoordCache {\n        bool cached;\n        uint256 x;\n        uint256 y;\n        uint256 tileData;\n    }\n\n    /// @notice Error thrown when a tile is not found in the map\n    error TileMissing();\n\n    /// @notice Check if a coordinate exists in the map\n    /// @param self The map to check\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @return bool True if the coordinate exists in the map\n    function contain(Map storage self, uint256 x, uint256 y) public view returns (bool) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            return false;\n        }\n        return self.values[idx - 1].contain(x, y);\n    }\n\n    /// @notice Check if a tile of given size exists at coordinates\n    /// @param self The map to check\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size of tile to check for\n    /// @return bool True if the tile exists at the coordinates\n    function contain(Map storage self, uint256 x, uint256 y, uint256 size) public view returns (bool) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            return false;\n        }\n        // TODO: We can call TileLib directly to use less gas ?\n        return self.values[idx - 1].contain(x, y, size);\n    }\n\n    /// @notice Check if a specific tile exists in the map\n    /// @param self The map to check\n    /// @param tile The tile to look for\n    /// @return bool True if the tile exists in the map\n    function containTileWithCoord(\n        Map storage self,\n        TileWithCoordLib.TileWithCoord memory tile\n    ) public view returns (bool) {\n        uint256 key = tile.getKey();\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            return false;\n        }\n        return self.values[idx - 1].contain(tile);\n    }\n\n    /// @notice Check if one map contains all tiles from another map\n    /// @dev self can be huge, but contained must be small, we iterate over contained values\n    /// @param self The map to check against\n    /// @param contained The map that should be contained\n    /// @return bool True if self contains all tiles from contained\n    function containMap(Map storage self, Map storage contained) public view returns (bool) {\n        uint256 len = contained.values.length;\n        for (uint256 i; i < len; ++i) {\n            if (!containTileWithCoord(self, contained.values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Set a tile of given size at coordinates\n    /// @param self The map to modify\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size of tile to set\n    function set(Map storage self, uint256 x, uint256 y, uint256 size) public {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            // Add a new tile\n            TileWithCoordLib.TileWithCoord memory t = TileWithCoordLib.initTileWithCoord(x, y);\n            self.values.push(t.set(x, y, size));\n            self.indexes[key] = self.values.length;\n        } else {\n            // contains\n            self.values[idx - 1] = self.values[idx - 1].set(x, y, size);\n        }\n    }\n\n    /// @notice Set a specific tile in the map\n    /// @param self The map to modify\n    /// @param tile The tile to set\n    function setTileWithCoord(Map storage self, TileWithCoordLib.TileWithCoord memory tile) public {\n        uint256 key = tile.getKey();\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            // Add a new tile\n            self.values.push(tile);\n            self.indexes[key] = self.values.length;\n        } else {\n            self.values[idx - 1] = self.values[idx - 1].merge(tile);\n        }\n    }\n\n    /// @notice Set all tiles from one map into another\n    /// @param self The destination map\n    /// @param contained The source map with tiles to set\n    function setMap(Map storage self, Map storage contained) public {\n        uint256 len = contained.values.length;\n        for (uint256 i; i < len; ++i) {\n            setTileWithCoord(self, contained.values[i]);\n        }\n    }\n\n    /// @notice Clear a tile of given size at coordinates\n    /// @param self The map to modify\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size of tile to clear\n    /// @return bool True if a tile was cleared\n    function clear(Map storage self, uint256 x, uint256 y, uint256 size) public returns (bool) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains, nothing to clear\n            return false;\n        }\n        TileWithCoordLib.TileWithCoord memory t = self.values[idx - 1].clear(x, y, size);\n        if (t.isEmpty()) {\n            _remove(self, idx, key);\n        } else {\n            self.values[idx - 1] = t;\n        }\n        return true;\n    }\n\n    /// @notice Clear a specific tile from the map\n    /// @param self The map to modify\n    /// @param tile The tile to clear\n    /// @return bool True if the tile was cleared\n    function clearTileWithCoord(Map storage self, TileWithCoordLib.TileWithCoord memory tile) public returns (bool) {\n        uint256 key = tile.getKey();\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            return false;\n        }\n        TileWithCoordLib.TileWithCoord memory t = self.values[idx - 1].subtract(tile);\n        if (t.isEmpty()) {\n            _remove(self, idx, key);\n        } else {\n            self.values[idx - 1] = t;\n        }\n        return true;\n    }\n\n    /// @notice Clear all tiles from one map that exist in another map\n    /// @param self The map to clear from\n    /// @param contained The map containing tiles to clear\n    function clearMap(Map storage self, Map storage contained) public {\n        uint256 len = contained.values.length;\n        for (uint256 i; i < len; ++i) {\n            clearTileWithCoord(self, contained.values[i]);\n        }\n    }\n\n    /// @notice Clear all tiles from the map\n    /// @param self The map to clear\n    function clear(Map storage self) public {\n        uint256 len = self.values.length;\n        for (uint256 i; i < len; ++i) {\n            delete self.indexes[self.values[i].getKey()];\n            delete self.values[i];\n        }\n        delete self.values;\n    }\n\n    /// @notice Check if the map is empty\n    /// @param self The map to check\n    /// @return bool True if the map is empty\n    /// @dev We remove the tiles when they are empty\n    function isEmpty(Map storage self) public view returns (bool) {\n        return self.values.length == 0;\n    }\n\n    /// @notice Check if two maps are equal\n    /// @param self First map to compare\n    /// @param other Second map to compare\n    /// @return bool True if maps are equal\n    function isEqual(Map storage self, Map storage other) public view returns (bool) {\n        return isEqual(self, other.values);\n    }\n\n    /// @notice Check if a map equals an array of tiles\n    /// @param self The map to compare\n    /// @param other Array of tiles to compare against\n    /// @return bool True if map equals the tiles array\n    function isEqual(Map storage self, TileWithCoordLib.TileWithCoord[] memory other) public view returns (bool) {\n        if (other.length != self.values.length) {\n            return false;\n        }\n        uint256 cant = other.length;\n        // Check that self contains the same set of tiles than other and they are equal\n        for (uint256 i; i < cant; ++i) {\n            uint256 key = other[i].getKey();\n            uint256 idx = self.indexes[key];\n            if (idx == 0 || !self.values[idx - 1].isEqual(other[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Get the number of tiles in the map\n    /// @param self The map to check\n    /// @return uint256 Number of tiles\n    function length(Map storage self) public view returns (uint256) {\n        return self.values.length;\n    }\n\n    /// @notice Get the tile at a specific index\n    /// @param self The map to get from\n    /// @param index The index to get\n    /// @return TileWithCoord The tile at the index\n    function at(Map storage self, uint256 index) public view returns (TileWithCoordLib.TileWithCoord memory) {\n        return self.values[index];\n    }\n\n    /// @notice Get a range of tiles from the map\n    /// @param self The map to get from\n    /// @param offset Starting index\n    /// @param limit Number of tiles to get\n    /// @return TileWithCoord[] Array of tiles\n    function at(\n        Map storage self,\n        uint256 offset,\n        uint256 limit\n    ) public view returns (TileWithCoordLib.TileWithCoord[] memory) {\n        TileWithCoordLib.TileWithCoord[] memory ret = new TileWithCoordLib.TileWithCoord[](limit);\n        for (uint256 i; i < limit; ++i) {\n            ret[i] = self.values[offset + i];\n        }\n        return ret;\n    }\n\n    /// @notice Get all tiles from the map\n    /// @param self The map to get from\n    /// @return TileWithCoord[] Array of all tiles\n    /// @dev This can be problematic if it grows too much!\n    function getMap(Map storage self) public view returns (TileWithCoordLib.TileWithCoord[] memory) {\n        return self.values;\n    }\n\n    /// @notice Check if a tile exists at coordinates (for testing)\n    /// @param self The map to check\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @return bool True if a tile exists at coordinates\n    function containTileAtCoord(Map storage self, uint256 x, uint256 y) public view returns (bool) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        return (idx != 0);\n    }\n\n    /// @notice Check if all tiles in the map are adjacent\n    /// @param self The map to check\n    /// @return ret True if all tiles are adjacent\n    function isAdjacent(Map storage self) public view returns (bool ret) {\n        TileLib.Tile[] memory spot = new TileLib.Tile[](self.values.length);\n        // We assume that all self.values[] are non empty (we remove them if they are empty).\n        spot[0] = self.values[0].tile.findAPixel();\n        return _isAdjacent(self, spot);\n    }\n\n    /// @notice Check if a tile at specific coordinates is adjacent to other tiles\n    /// @param self The map to check\n    /// @param x The x coordinate of the tile\n    /// @param y The y coordinate of the tile\n    /// @return ret True if the tile is adjacent to other tiles\n    /// @dev passing the extra initial coordinate can be used to save gas by doing some off-chain calculation\n    function isAdjacent(Map storage self, uint256 x, uint256 y) public view returns (bool ret) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        uint256 idx = self.indexes[key];\n        if (idx == 0) {\n            // !contains\n            return false;\n        }\n        TileWithCoordLib.TileWithCoord memory t = self.values[idx - 1];\n        TileLib.Tile[] memory spot = new TileLib.Tile[](self.values.length);\n        spot[idx - 1] = t.tile;\n        if (!t.contain(x, y)) {\n            // !contains\n            return false;\n        }\n        return _isAdjacent(self, spot);\n    }\n\n    /// @notice Constants for bit masking operations\n    uint256 private constant LEFT_MASK = 0x0001000100010001000100010001000100010001000100010001000100010001;\n    uint256 private constant LEFT_MASK_NEG = ~LEFT_MASK;\n    uint256 private constant RIGHT_MASK = 0x8000800080008000800080008000800080008000800080008000800080008000;\n    uint256 private constant RIGHT_MASK_NEG = ~RIGHT_MASK;\n    uint256 private constant UP_MASK = 0x000000000000000000000000000000000000000000000000000000000000FFFF;\n    uint256 private constant DOWN_MASK = 0xFFFF000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice Grow a tile by one pixel in all directions\n    /// @param x The tile data to grow\n    /// @return uint256 The grown tile data\n    function grow(uint256 x) private pure returns (uint256) {\n        return (x | ((x & RIGHT_MASK_NEG) << 1) | ((x & LEFT_MASK_NEG) >> 1) | (x << 16) | (x >> 16));\n    }\n\n    /// @notice Perform one step of the flood fill algorithm\n    /// @param self The map being flood filled\n    /// @param current Current state of flood fill\n    /// @return next Updated flood fill state\n    /// @return done True if flood fill is complete\n    function floodStep(\n        Map storage self,\n        TileLib.Tile[] memory current\n    ) public view returns (TileLib.Tile[] memory next, bool done) {\n        TileWithCoordCache[] memory cache = new TileWithCoordCache[](self.values.length);\n        return _floodStep(self, current, cache);\n    }\n\n    /// @notice Check if a rectangle is adjacent to the current map\n    /// @param self The map to check against\n    /// @param x The x coordinate of rectangle\n    /// @param y The y coordinate of rectangle\n    /// @param size Size of the rectangle\n    /// @return bool True if rectangle is adjacent to map\n    /// @dev Used to check a rectangle. Cheaper than isAdjacent(map)\n    function isAdjacent(Map storage self, uint256 x, uint256 y, uint256 size) public view returns (bool) {\n        uint256 idx;\n        TileLib.Tile memory spot;\n        TileLib.ExtendedTile memory corners = spot.set(x % 16, y % 16, size).grow();\n\n        // left\n        if (x >= 16) {\n            idx = _getIdx(self, x - 16, y);\n            if (idx != 0 && self.values[idx - 1].tile.isAdjacent(corners.left)) {\n                return true;\n            }\n        }\n        // up\n        if (y >= 16) {\n            idx = _getIdx(self, x, y - 16);\n            if (idx != 0 && self.values[idx - 1].tile.isAdjacent(corners.up)) {\n                return true;\n            }\n        }\n        // middle\n        idx = _getIdx(self, x, y);\n        if (idx != 0 && self.values[idx - 1].tile.isAdjacent(corners.middle)) {\n            return true;\n        }\n        // down\n        idx = _getIdx(self, x, y + 16);\n        if (idx != 0 && self.values[idx - 1].tile.isAdjacent(corners.down)) {\n            return true;\n        }\n        // right\n        idx = _getIdx(self, x + 16, y);\n        if (idx != 0 && self.values[idx - 1].tile.isAdjacent(corners.right)) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Move tiles from one map to another\n    /// @param from Source map\n    /// @param to Destination map\n    /// @param tiles Tiles to move\n    function moveTo(Map storage from, Map storage to, TileWithCoordLib.TileWithCoord[] calldata tiles) public {\n        for (uint256 i; i < tiles.length; ++i) {\n            if (!containTileWithCoord(from, tiles[i])) {\n                revert TileMissing();\n            }\n            clearTileWithCoord(from, tiles[i]);\n            setTileWithCoord(to, tiles[i]);\n        }\n    }\n\n    /// @notice Add tiles to a map\n    /// @param self The map to add to\n    /// @param tiles Tiles to add\n    function add(Map storage self, TileWithCoordLib.TileWithCoord[] calldata tiles) public {\n        for (uint256 i; i < tiles.length; ++i) {\n            setTileWithCoord(self, tiles[i]);\n        }\n    }\n\n    /// @notice Remove tiles from a map\n    /// @param self The map to remove from\n    /// @param tiles Tiles to remove\n    function remove(Map storage self, TileWithCoordLib.TileWithCoord[] calldata tiles) public {\n        for (uint256 i; i < tiles.length; ++i) {\n            if (!containTileWithCoord(self, tiles[i])) {\n                revert TileMissing();\n            }\n            clearTileWithCoord(self, tiles[i]);\n        }\n    }\n\n    /// @notice Internal function to remove a tile from the map\n    /// @param self The map to remove from\n    /// @param idx Index of tile to remove\n    /// @param key Key of tile to remove\n    function _remove(Map storage self, uint256 idx, uint256 key) private {\n        // TODO: We remove an empty tile, maybe is just better to leave it there ?\n        uint256 toDeleteIndex = idx - 1;\n        uint256 lastIndex = self.values.length - 1;\n        if (lastIndex != toDeleteIndex) {\n            TileWithCoordLib.TileWithCoord memory lastValue = self.values[lastIndex];\n            self.values[toDeleteIndex] = lastValue;\n            self.indexes[lastValue.getKey()] = idx;\n        }\n        self.values.pop();\n        delete self.indexes[key];\n    }\n\n    /// @notice Get index for a tile at coordinates\n    /// @param self The map to get from\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @return uint256 Index of tile\n    function _getIdx(Map storage self, uint256 x, uint256 y) private view returns (uint256) {\n        uint256 key = TileWithCoordLib.getKey(x, y);\n        return self.indexes[key];\n    }\n\n    /// @notice Internal function to check if all tiles in map are adjacent using flood fill\n    /// @param self The map to check adjacency in\n    /// @param spot Array of tiles representing current flood fill state\n    /// @return ret True if all tiles are adjacent to each other\n    /// @dev Uses flood fill algorithm to check connectivity between tiles\n    function _isAdjacent(Map storage self, TileLib.Tile[] memory spot) private view returns (bool ret) {\n        uint256 len = self.values.length;\n        TileWithCoordCache[] memory cache = new TileWithCoordCache[](len);\n        bool done;\n        while (!done) {\n            (spot, done) = _floodStep(self, spot, cache);\n        }\n        uint256 i;\n        for (; i < len; ++i) {\n            if (spot[i].data != cache[i].tileData) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Perform one step of the flood fill algorithm\n    /// @param self The map being flood filled\n    /// @param current Current state of flood fill\n    /// @param cache in memory copy of self.values\n    /// @return next Updated flood fill state\n    /// @return done True if flood fill is complete\n    function _floodStep(\n        Map storage self,\n        TileLib.Tile[] memory current,\n        TileWithCoordCache[] memory cache\n    ) private view returns (TileLib.Tile[] memory next, bool done) {\n        uint256 i;\n        uint256 x;\n        uint256 y;\n        uint256 idx;\n        TileLib.Tile memory ci;\n\n        uint256 len = current.length;\n        next = new TileLib.Tile[](len);\n        // grow\n        for (i; i < len; ++i) {\n            ci = current[i];\n            // isEmpty\n            if (ci.data == 0) {\n                continue;\n            }\n            // TODO: check if it is better to use in-memory Tile or TileWithCoords\n            (x, y, ) = _getFromCache(self, cache, i);\n\n            // left\n            if (x >= 16) {\n                idx = _getIdx(self, x - 16, y);\n                if (idx != 0) {\n                    next[idx - 1].data |= (ci.data & LEFT_MASK) << 15;\n                }\n            }\n            // up\n            if (y >= 16) {\n                idx = _getIdx(self, x, y - 16);\n                if (idx != 0) {\n                    next[idx - 1].data |= (ci.data & UP_MASK) << (16 * 15);\n                }\n            }\n            // middle\n            idx = _getIdx(self, x, y);\n            if (idx != 0) {\n                next[idx - 1].data |= grow(ci.data);\n            }\n            // down\n            idx = _getIdx(self, x, y + 16);\n            if (idx != 0) {\n                next[idx - 1].data |= (ci.data & DOWN_MASK) >> (16 * 15);\n            }\n            // right\n            idx = _getIdx(self, x + 16, y);\n            if (idx != 0) {\n                next[idx - 1].data |= (ci.data & RIGHT_MASK) >> 15;\n            }\n        }\n        // Mask it.\n        done = true;\n        for (i = 0; i < len; ++i) {\n            (, , x) = _getFromCache(self, cache, i);\n            next[i].data = next[i].data & x;\n            done = done && next[i].data == current[i].data;\n        }\n        return (next, done);\n    }\n\n    /// @notice Get cached tile coordinates and data or fetch from storage if not cached\n    /// @param self The map to get from\n    /// @param cache Array to cache tile information\n    /// @param i Index of the tile to get\n    /// @return uint256 X coordinate of the tile\n    /// @return uint256 Y coordinate of the tile\n    /// @return uint256 Tile data\n    /// @dev Internal helper function to optimize repeated tile access\n    function _getFromCache(\n        Map storage self,\n        TileWithCoordCache[] memory cache,\n        uint256 i\n    ) internal view returns (uint256, uint256, uint256) {\n        TileWithCoordCache memory c = cache[i];\n        if (!c.cached) {\n            TileWithCoordLib.TileWithCoord storage t = self.values[i];\n            c.cached = true;\n            c.x = t.getX();\n            c.y = t.getY();\n            c.tileData = t.tile.data;\n        }\n        return (c.x, c.y, c.tileData);\n    }\n}\n"
      },
      "project/contracts/TileLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title TileLib\n/// @author aadjiman@gmail.com\n/// @notice a library to manage tiles, a two dimensional 16x16 boolean bitmap\n/// @dev TODO: Consider removing requires to save some gas\nlibrary TileLib {\n    /// @notice Represents an extended tile with left, right, up, down and middle sections\n    struct ExtendedTile {\n        Tile left;\n        uint256 up; // just one line\n        Tile middle;\n        uint256 down; // just one line\n        Tile right;\n    }\n\n    /// @notice Represents a single tile as a 256-bit bitmap\n    struct Tile {\n        uint256 data;\n    }\n\n    /// @notice Invalid size error\n    /// @param size The invalid size value\n    error InvalidSize(uint256 size);\n\n    /// @notice Error for invalid coordinates in a tile operation\n    /// @param x The x coordinate that caused the error\n    /// @param y The y coordinate that caused the error\n    error InvalidCoordinates(uint256 x, uint256 y);\n\n    /// @notice initialize a tile\n    /// @return return an empty tile\n    function initTile() internal pure returns (Tile memory) {\n        Tile memory ret;\n        return ret;\n    }\n\n    /// @notice get a clone of the tile to be able to modify it\n    /// @param self The tile to clone\n    /// @return A new tile with the same data\n    function clone(Tile memory self) internal pure returns (Tile memory) {\n        return Tile(self.data);\n    }\n\n    /// @notice Sets bits in a tile for a given rectangle\n    /// @param self The tile to modify\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size of the square to set\n    /// @return The modified tile\n    function set(Tile memory self, uint256 x, uint256 y, uint256 size) internal pure returns (Tile memory) {\n        if (size == 0 || size > 16) {\n            revert InvalidSize(size);\n        }\n        if (x + size > 16 || y + size > 16) {\n            revert InvalidCoordinates(x, y);\n        }\n        self.data |= _getRectangleMask(x, y, size);\n        return self;\n    }\n\n    /// @notice Clears bits in a tile for a given rectangle\n    /// @param self The tile to modify\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size of the square to clear\n    /// @return The modified tile\n    function clear(Tile memory self, uint256 x, uint256 y, uint256 size) internal pure returns (Tile memory) {\n        if (size == 0 || size > 16) {\n            revert InvalidSize(size);\n        }\n        if (x + size > 16 || y + size > 16) {\n            revert InvalidCoordinates(x, y);\n        }\n        self.data &= ~_getRectangleMask(x, y, size);\n        return self;\n    }\n\n    /// @notice Checks if a specific point in the tile is set\n    /// @param self The tile to check\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @return True if point is set, false otherwise\n    function contain(Tile memory self, uint256 x, uint256 y) internal pure returns (bool) {\n        if (x < 16 && y < 16) {\n            uint256 bitMask = 1 << (x + 16 * y);\n            return (self.data & bitMask == bitMask);\n        }\n        return false;\n    }\n\n    /// @notice Checks if a rectangle of given size is set in the tile\n    /// @param self The tile to check\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @param size The size to check\n    /// @return True if rectangle is set, false otherwise\n    function contain(Tile memory self, uint256 x, uint256 y, uint256 size) internal pure returns (bool) {\n        if (size == 0 || size > 16 || x + size > 16 || y + size > 16) {\n            return false;\n        }\n        uint256 bitMask = _getRectangleMask(x, y, size);\n        return (self.data & bitMask == bitMask);\n    }\n\n    /// @notice Checks if one tile is fully contained within another\n    /// @param self The container tile\n    /// @param contained The tile that should be contained\n    /// @return True if contained tile is within self\n    function contain(Tile memory self, Tile memory contained) internal pure returns (bool) {\n        return (self.data & contained.data == contained.data);\n    }\n\n    /// @notice Checks if tile is empty (all bits 0)\n    /// @param self The tile to check\n    /// @return True if empty, false otherwise\n    function isEmpty(Tile memory self) internal pure returns (bool) {\n        return self.data == 0;\n    }\n\n    /// @notice Checks if two tiles are equal\n    /// @param self The first tile\n    /// @param b The second tile\n    /// @return True if equal, false otherwise\n    function isEqual(Tile memory self, Tile memory b) internal pure returns (bool) {\n        return self.data == b.data;\n    }\n\n    /// @notice Performs bitwise OR between two tiles\n    /// @param self The first tile\n    /// @param b The second tile\n    /// @return The result tile\n    function or(Tile memory self, Tile memory b) internal pure returns (Tile memory) {\n        self.data |= b.data;\n        return self;\n    }\n\n    /// @notice Performs bitwise NOT operation on a tile\n    /// @param self The tile to invert\n    /// @return The inverted tile\n    function not(Tile memory self) internal pure returns (Tile memory) {\n        self.data = ~self.data;\n        return self;\n    }\n    /// @notice Performs bitwise AND between two tiles\n    /// @param self The first tile\n    /// @param b The second tile\n    /// @return The result tile\n    function and(Tile memory self, Tile memory b) internal pure returns (Tile memory) {\n        self.data &= b.data;\n        return self;\n    }\n\n    /// @notice Subtracts one tile from another\n    /// @param self The tile to subtract from\n    /// @param value The tile to subtract\n    /// @return The result tile\n    function subtract(Tile memory self, Tile memory value) internal pure returns (Tile memory) {\n        self.data &= ~value.data;\n        return self;\n    }\n\n    /// @dev Bit masks for tile edges\n    uint256 private constant LEFT_MASK = 0x0001000100010001000100010001000100010001000100010001000100010001;\n    uint256 private constant LEFT_MASK_NEG = ~LEFT_MASK;\n    uint256 private constant RIGHT_MASK = 0x8000800080008000800080008000800080008000800080008000800080008000;\n    uint256 private constant RIGHT_MASK_NEG = ~RIGHT_MASK;\n    uint256 private constant UP_MASK = 0x000000000000000000000000000000000000000000000000000000000000FFFF;\n    uint256 private constant DOWN_MASK = 0xFFFF000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice Grows a tile by one pixel in all directions\n    /// @param self The tile to grow\n    /// @return e The extended tile result\n    function grow(Tile memory self) internal pure returns (ExtendedTile memory e) {\n        e.middle.data = grow(self.data);\n        e.up = (self.data & UP_MASK) << (16 * 15);\n        e.down = (self.data & DOWN_MASK) >> (16 * 15);\n        e.left.data = (self.data & LEFT_MASK) << 15;\n        e.right.data = (self.data & RIGHT_MASK) >> 15;\n        return e;\n    }\n\n    /// @notice Helper function to grow a raw bitmap value\n    /// @param x The value to grow\n    /// @return The grown value\n    function grow(uint256 x) private pure returns (uint256) {\n        return (x | ((x & RIGHT_MASK_NEG) << 1) | ((x & LEFT_MASK_NEG) >> 1) | (x << 16) | (x >> 16));\n    }\n\n    /// @notice Checks if tile is adjacent to a raw bitmap value\n    /// @param self The tile to check\n    /// @param val The value to check against\n    /// @return True if adjacent, false otherwise\n    function isAdjacent(Tile memory self, uint256 val) internal pure returns (bool) {\n        return (self.data & val) != 0;\n    }\n\n    /// @notice Checks if two tiles are adjacent\n    /// @param self The first tile\n    /// @param val The second tile\n    /// @return True if adjacent, false otherwise\n    function isAdjacent(Tile memory self, Tile memory val) internal pure returns (bool) {\n        return (self.data & val.data) != 0;\n    }\n\n    /// @notice Finds a single set pixel in the tile\n    /// @dev If the user wants to prove adjacency we can take a pixel as argument instead of searching\n    /// @param self The tile to search\n    /// @return ret A new tile with single found pixel set\n    function findAPixel(Tile memory self) internal pure returns (Tile memory ret) {\n        uint256 shift;\n\n        if (self.data != 0) {\n            shift = findAPixel(self.data);\n            ret.data = ret.data | (1 << shift);\n        }\n        return ret;\n    }\n\n    /// @notice Helper function to find first set bit in raw value\n    /// @param target The value to search\n    /// @return shift The bit position found\n    function findAPixel(uint256 target) private pure returns (uint256 shift) {\n        uint256 mask = (2 ** 256 - 1);\n        for (uint256 i = 128; i > 0; i = i / 2) {\n            mask = mask >> i;\n            if ((target & mask) == 0) {\n                target = target >> i;\n                shift += i;\n            }\n        }\n        return shift;\n    }\n    /// @notice Helper function to create a bitmap mask for a rectangle\n    /// @param x The x coordinate where the rectangle starts\n    /// @param y The y coordinate where the rectangle starts\n    /// @param size The size of the rectangle (both width and height)\n    /// @return mask The bitmap mask for the specified rectangle\n    function _getRectangleMask(uint256 x, uint256 y, uint256 size) private pure returns (uint256 mask) {\n        uint256 lineMask = ((2 ** size) - 1) << x;\n        for (uint256 i; i < size; ++i) {\n            mask |= lineMask << (16 * (y + i));\n        }\n        return mask;\n    }\n}\n"
      },
      "project/contracts/TileWithCoordLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {TileLib} from \"./TileLib.sol\";\n\n/// @title TileWithCoordLib\n/// @author aadjiman@gmail.com\n/// @notice A square of 16x16 bits with coordinates\n/// @dev Library for managing tiles with coordinates in a 16x16 grid\nlibrary TileWithCoordLib {\n    using TileLib for TileLib.Tile;\n\n    /// @notice Structure representing a tile with coordinates\n    /// @param coord Combined x,y coordinate (x in lower 128 bits, y in upper 128 bits)\n    /// @param tile The tile data structure\n    struct TileWithCoord {\n        uint256 coord;\n        TileLib.Tile tile;\n    }\n\n    /// @notice Error for invalid coordinates in a tile operation\n    /// @param x0 The x coordinate of the first tile\n    /// @param y0 The y coordinate of the first tile\n    /// @param x1 The x coordinate of the second tile\n    /// @param y1 The y coordinate of the second tile\n    error InvalidCoordinates(uint256 x0, uint256 y0, uint256 x1, uint256 y1);\n\n    /// @notice Initialize a new tile with coordinates\n    /// @param x The x coordinate (must be multiple of 16)\n    /// @param y The y coordinate (must be multiple of 16)\n    /// @return A new TileWithCoord initialized at the given coordinates\n    /// @dev TileWithCoord x and y always start in multiples of 16\n    function initTileWithCoord(uint256 x, uint256 y) internal pure returns (TileWithCoord memory) {\n        TileWithCoord memory ret;\n        ret.coord = getKey(x, y);\n        return ret;\n    }\n\n    /// @notice Set bits in the tile at specified coordinates\n    /// @param self The tile to modify\n    /// @param xi The x coordinate to set\n    /// @param yi The y coordinate to set\n    /// @param size The size of the area to set\n    /// @return The modified tile\n    function set(\n        TileWithCoord memory self,\n        uint256 xi,\n        uint256 yi,\n        uint256 size\n    ) internal pure returns (TileWithCoord memory) {\n        if (getXInt(self) != xi / 16 || getYInt(self) != yi / 16) {\n            revert InvalidCoordinates(getX(self), getY(self), xi, yi);\n        }\n        self.tile = self.tile.set(xi % 16, yi % 16, size);\n        return self;\n    }\n\n    /// @notice Clear bits in the tile at specified coordinates\n    /// @param self The tile to modify\n    /// @param xi The x coordinate to clear\n    /// @param yi The y coordinate to clear\n    /// @param size The size of the area to clear\n    /// @return The modified tile\n    function clear(\n        TileWithCoord memory self,\n        uint256 xi,\n        uint256 yi,\n        uint256 size\n    ) internal pure returns (TileWithCoord memory) {\n        if (getXInt(self) != xi / 16 || getYInt(self) != yi / 16) {\n            revert InvalidCoordinates(getX(self), getY(self), xi, yi);\n        }\n        self.tile = self.tile.clear(xi % 16, yi % 16, size);\n        return self;\n    }\n\n    /// @notice Merge two tiles using OR operation\n    /// @param self The base tile\n    /// @param value The tile to merge into base\n    /// @return The merged tile\n    function merge(TileWithCoord memory self, TileWithCoord memory value) internal pure returns (TileWithCoord memory) {\n        if (getXInt(self) != getXInt(value) || getYInt(self) != getYInt(value)) {\n            revert InvalidCoordinates(getX(self), getY(self), getX(value), getY(value));\n        }\n        self.tile = self.tile.or(value.tile);\n        return self;\n    }\n\n    /// @notice Subtract one tile from another\n    /// @param self The base tile\n    /// @param value The tile to subtract\n    /// @return The resulting tile\n    function subtract(\n        TileWithCoord memory self,\n        TileWithCoord memory value\n    ) internal pure returns (TileWithCoord memory) {\n        if (getXInt(self) != getXInt(value) || getYInt(self) != getYInt(value)) {\n            revert InvalidCoordinates(getX(self), getY(self), getX(value), getY(value));\n        }\n        self.tile = self.tile.subtract(value.tile);\n        return self;\n    }\n\n    /// @notice Check if tile contains a point\n    /// @param self The tile to check\n    /// @param xi X coordinate of the point\n    /// @param yi Y coordinate of the point\n    /// @return True if the point is set in the tile\n    function contain(TileWithCoord memory self, uint256 xi, uint256 yi) internal pure returns (bool) {\n        if (getXInt(self) != xi / 16 || getYInt(self) != yi / 16) {\n            return false;\n        }\n        return self.tile.contain(xi % 16, yi % 16);\n    }\n\n    /// @notice Check if tile contains an area\n    /// @param self The tile to check\n    /// @param xi X coordinate of the area\n    /// @param yi Y coordinate of the area\n    /// @param size Size of the area\n    /// @return True if the entire area is set in the tile\n    function contain(TileWithCoord memory self, uint256 xi, uint256 yi, uint256 size) internal pure returns (bool) {\n        if (getXInt(self) != xi / 16 || getYInt(self) != yi / 16) {\n            return false;\n        }\n        return self.tile.contain(xi % 16, yi % 16, size);\n    }\n\n    /// @notice Check if one tile contains another\n    /// @param self The container tile\n    /// @param contained The tile to check if contained\n    /// @return True if contained tile is fully contained within self\n    function contain(TileWithCoord memory self, TileWithCoord memory contained) internal pure returns (bool) {\n        return getX(self) == getX(contained) && getY(self) == getY(contained) && self.tile.contain(contained.tile);\n    }\n\n    /// @notice Get the coordinate key of a tile\n    /// @param self The tile\n    /// @return The coordinate key\n    function getKey(TileWithCoord memory self) internal pure returns (uint256) {\n        return self.coord;\n    }\n\n    /// @notice Get the x coordinate of a tile\n    /// @param self The tile\n    /// @return The x coordinate (multiple of 16)\n    function getX(TileWithCoord memory self) internal pure returns (uint256) {\n        return getXInt(self) * 16;\n    }\n\n    /// @notice Get the y coordinate of a tile\n    /// @param self The tile\n    /// @return The y coordinate (multiple of 16)\n    function getY(TileWithCoord memory self) internal pure returns (uint256) {\n        return getYInt(self) * 16;\n    }\n\n    /// @notice Get the x coordinate integer\n    /// @param self The tile\n    /// @return The x coordinate divided by 16\n    function getXInt(TileWithCoord memory self) private pure returns (uint256) {\n        return self.coord & (2 ** 128 - 1);\n    }\n\n    /// @notice Get the y coordinate integer\n    /// @param self The tile\n    /// @return The y coordinate divided by 16\n    function getYInt(TileWithCoord memory self) private pure returns (uint256) {\n        return self.coord >> 128;\n    }\n\n    /// @notice Get coordinate key from x,y coordinates\n    /// @param x The x coordinate\n    /// @param y The y coordinate\n    /// @return The coordinate key\n    function getKey(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x / 16) + ((y / 16) << 128);\n    }\n\n    /// @notice Check if a tile is empty\n    /// @param self The tile to check\n    /// @return True if the tile has no bits set\n    function isEmpty(TileWithCoord memory self) internal pure returns (bool) {\n        return self.tile.isEmpty();\n    }\n\n    /// @notice Check if two tiles are equal\n    /// @param self First tile\n    /// @param other Second tile\n    /// @return True if the tiles have identical data\n    function isEqual(TileWithCoord memory self, TileWithCoord memory other) internal pure returns (bool) {\n        return self.tile.data == other.tile.data;\n    }\n}\n"
      }
    }
  }
}